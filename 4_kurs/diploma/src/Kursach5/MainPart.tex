\newpage
\section{Оптимізація метрик та прикладах}
Через те що в метрики дуже пов'язані одна з одною я наведу приклади як я зміг оптимізувати сторінку.
Усі ці способи допомогою оптимізувати сторінку, та є ефективними.
\subsection{Відкладання загрузки непотрібних компонентів}
Цей прийом є дуже ефективним при оптимізації. Наприклад хедер є доволі складною компонентою сайту бо має адаптуватись до розміру та іноді містить у собі багато логіки.
Після того як було зроблено лінива загрузка швидкість була покращена.

Фреймворк NextJs допомагав у цьому. Для того щоб зробити загрузку лінивою треба було лише використати так завний динамік імпорт.
Кількість необхідного коду час першої загрузки зменшилися на 80 кілобайт.
Для контролю Cumulative Layout Shift(дивитись нижче) Рекомендується використовувати компоненту з назвою Skeleton.
Вона дозволяє створити відчуття неперервної загрузки сторінки та недергану. \\
Замість цього коду.
\begin{lstlisting}[basicstyle=\small]
import Box from "./Header/Header";
\end{lstlisting}
Вставляємо цей
\begin{lstlisting}[basicstyle=\small, language=JavaScript]
const Header = dynamic(() => import("./Header/Header"), {
    ssr: false,
    loading: () => (
    <Skeleton component="div"
              variant="rect"
              width="100vw"
              height="100px" />
    ),
});
\end{lstlisting}
Ця зміна коду зменшила розмір \textit{First Load JS} на 80kB, а це скорочення на 30-40\% відносно початкового значення у випадку звичайної сторінки.
Це трапилось через те що хедер є дуже складною компонентою і має багато функцій.
Однак він не потрібен у перші секунди використання сторінки. \\
Ця оптимізація підвищила швидкість сайту на час близький до секунди. Це є дуже багато.
\subsection{Адаптивні зображення}
Адаптивні зображення є необхідним, чи не необхібхіднішою частиною для швидкої роботи сторінки, але звісно лише для тих які мають багато зображень.
Стандарт html 5 додав можливість робити загрузку картинок адаптивною тобто враховуючи параметри такі як ширина екрану в пікселях(стандартизованих),
щільність пікселів тобто наприклад для 4К дисплею треба вочевидь загружати більш якісну картинку.

Це робиться приблизно таким чином: вказується функція з ширини екрану та щільністі пікселів у посилання на картинку.
Фреймворк Next має можливість автоматичної оптимізації та створення картинок відповідного розміру, це є дуже ефективним з точки зору часу розробки та фокусуванні на задачі.
Він також переводить картинки у формат webp.
Це покращує метрики такі як LCP, Та інші.
Приклади коду.

\subsection{Відмова від непотрібних бібліотек}
Гарним правилом є підключати тільки найбільш необхідні бібліотеки.
Вони мають бути правильно зробленими, дозволяти code splitting, про це пізніше.
У моєму випадку гарним правилом є підключати лише фреймворк наприклад MaterialUI та бібліотеку для роботи з формами.
Також інші бібліотеки підключати лише за необхідностію, і якщо можна зробити щось самостійно і більш-менш швидко
та якісно -- робіть це.

Наприклад спочатку footer сайту був взятий з бібліотеки з третьої сторони.
Зміна коду призвела до збільшення швидкості сайту доволі сильно.
Наприклад на моєму сайті є декілька основних бібліотек: вочевидь фреймворки React, NextJs,MaterialUI, Formik, Markdown.

\subsection{Розділення коду(Code splitting)}
Розділення коду є дуже важливою частиною оптимізації сайту.
Webpack є основною основним інструментом для збірки сайту.
А суть цього підходу у тому що інструмент збірки лише додає у файл де записаний фінальний код, так званий minified js файл,
тільки те що де-факто використовується.
Для цього використовується named import.
Деякі інструменти такі як Babel можуть автоматизувати цей процес. \\

Я не зміг налаштувати Babel для цієї задачі.
Простим способом рекомендується робити іменовані і порти безпосередньо.
Це дозволить пришвидшити сайт.

Перший код буде працювати швидше, бо імпортує код використвуючи named import.
Це є необхідним, бо ще не розроблено готових до індустріального використання інструментів, які можуть розуміти,
який код в загальному випадку буде використаний.
\begin{lstlisting}
// Fast
import Button from '@material-ui/core/Button';
import TextField from '@material-ui/core/TextField';
\end{lstlisting}

\begin{lstlisting}
// Not so fast
import { Button, TextField } from '@material-ui/core';
\end{lstlisting}

\subsection{Слайдер}
Я додаю цю частину бо витратив багато часу на пошуки ефективного способу додавання слайдеру на вебсайт.
Мій рецепт буде використовувати бібліотеку keen-slider.
Ця бібліотека є однією з найкращих в інтернеті. Проте вона потребує деяких оптимізації.
Next має можливість пріоритезувати картинки загрузку картинок. (Про методи нижче)
Усі інші картинки будуть загружені лише після того як з'являться на екрані(так звана лінива загрузка).
Але цей функціонал засновується на еврістиках і не є ідеальним.
Для того щоби відкласти будь-яку загрузку картинок слайдеру до моменту поки вони будуть необхідно зробити так звану віртуалізацію.
Суть віртуалізації проста і заключається у тому щоб загружати тільки одну дві картинки наперед замість усіх слайдів.
Це є ще більш вагомим якщо присутня велика кількість слайдів.
Також у випадку коли слайдів дуже багато. Пріоритетзувати загрузку головного зображення є абсолютною необхідністю.
приклад коду

\subsection{Предзагрузка картинок}
Предзагрузка дозволяє сказати браузеру що картинка необхідно в 1-у чергу. Це дозволяє основні картинки загружати швидше.
Це покращує LCP та FCP. Все надає користувачу краще результати порівняно з звичайним перевірте там загрузки картинки.
Також це може застосовуватись у випадках коли відомо що картинка буде потрібна впродовж короткого терміну але на даний момент не видно на екрани.
Наприклад такий випадок я зустріну коли Робив слайдер для того щоб за гру жати тільки наступний слайд. Це дозволило покращити майже всі метрики бо знизило навантаження наПроцесор та мережу.

\begin{lstlisting}
<link rel="preload"
    as="image"
    href="wolf.jpg"
    imagesrcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w"
    imagesizes="50vw">
\end{lstlisting}

\subsection{Використання даних про клієнта}
У браузерах особливо в нових браузерах існує можливість дізнатися про деякі характеристики пристрою на якому він запущений.
Це дозволяє підстраюватись від необхідності клієнта, наприклад можна не робити анімовані переходи загружати менш якісні картинки,
та деякі речі взагалі не загружати і не використовувати.

Це може бути використана разом з динамічною загрузку(\textit{dynamic import}) компонент тобто починати загруз компоненти тільки у разі якщо клієнт її потребує.
В React є бібліотека яка дозволяє отримати такі дані у дуже простий спосіб.
Наприклад дані про з'єднання кількість пам'яті кількість процесорів.
На зображенні нижче ми бачимо, приклад адаптації медіа контенту в залежності від швидкості інтернету.
\begin{lstlisting}[basicstyle=\small]
import React from 'react';

import { useNetworkStatus } from 'react-adaptive-hooks/network';

const Component = () => {
    const { effectiveConnectionType } = useNetworkStatus();

    let media;
    switch(effectiveConnectionType) {
        case 'slow-2g':
        media = <img src='...' alt='low resolution'/>;
        break;
        case '2g':
        media = <img src='...' alt='medium resolution'/>;
        break;
        case '3g':
        media = <img src='...' alt='high resolution'/>;
        break;
        case '4g':
        media = <video muted controls>...</video>;
        break;
        default:
        media = <video muted controls>...</video>;
        break;
    }

    return <div>{media}</div>;
};

\end{lstlisting}
\subsection{Предзагрузка сторінок}
Ще способом оптимізації швидкості загрузки сторінок є предзагрузка самих сторінок тобто коли одно сторінка посилається на іншу
і знає що сво соколи долею імовірності людина перейди на іншу сторінку то можна додати інформацію HTML код за допомогою якої
браузер зрозуміє що треба предзагрузити іншу сторінку. Це суттєво знижує час загрузки іншої сторінки.
Використаний мною фреймворк робить використання такого підходу дуже простим та легко конфігуруваним.
Проте банально предзагружати усі сторінки не завжди є доцільним, можна представити сторінку товару з 10 варіантами
або на якій є посилання на 100 інших товарів.
В такому випадку рекомендується використовувати статистику сайту або автоматично або в ручному режимі для того щоб
розуміти які сторінки мають повинні мати пріорітет для предзагрузки.

Додавання \textbf{<link rel = prefetch>} на веб-сторінку повідомляє браузеру про завантаження цілих сторінок
або деяких ресурсів (таких як скрипти або файли CSS), які можуть знадобитися користувачеві в майбутньому.
Це може покращити такі показники, як First Contentful Paint та Time to Interactive,
і часто може спричинити негайне завантаження наступних сторінок.

Підказки щодо ресурсів не є обов’язковими інструкціями, і браузер сам вирішує, чи виконуватимуться вони і коли.

Ви можете використовувати попередню вибірку кілька разів на одній сторінці.
Браузер ставить у чергу всі підказки та запитує кожен ресурс, коли він не працює.
У Chrome, якщо попереднє завантаження не закінчилось завантаження,
і користувач переходить до призначеного ресурсу попереднього завантаження,
навантаження під час польоту підбирається як навігація браузером
(інші постачальники браузера можуть реалізувати це по-іншому).

Попереднє завантаження відбувається з пріоритетом "Найнижчий",
тому попередньо завантажені ресурси не конкурують за пропускну здатність з ресурсами,
необхідними на поточній сторінці.

Заздалегідь завантажені файли зберігаються в кеш-пам'яті HTTP або кеш-пам'яті
(залежно від того, кешується ресурс чи ні) протягом певного періоду часу,
який залежить від браузера. Наприклад, у Chrome ресурси зберігаються протягом п’яти хвилин,
після чого застосовуються звичайні правила управління кешем для ресурсу.
