\newpage
\section{Вибір способу розробки}
В процесі вибору способу розробки було зроблено декілька кроків.
Спочатку я спробував не використовувати сторонніх бібліотек.
Цей підхід виявився складним потребуючим глибоких знань у веб розробці та потребуючим великих зусиль для досягання
як на мене схожого на той що може бути отриманий з використанням готових рішень.
Цей спосіб підходить для невеликих проектів але вже існує багато фреймворків які спрощують і таку розробку.

Далі я спробував використати фреймворк React.
Разом з розширенням мови Javascript під назвою JSX Він дозволяє розроблювати фронтенд у у знайомий для більшості програмістів спосіб.
Код сторінки може бути оброблений як і будь-яка інша зміна.
React використовує ідеї функціонального реактивного програмування.
Зміни стану лежать повністю на бібліотеці.
Бібліотека надає API для зміни стану але безпосередньо зміна стану з робиться бібліотекою.
Бібліотека показала себе зручною у використанні та такою що є такою що підходить для задачі.
Перші спроби розробки за допомогою Реактор були зроблені на мові ReasonML.
Ця мова є функціональною та вона виявилися не підходящою для проекту бо з моєї точки зору орієнтована
на великі проекти з великим бюджетом а для малих проектів рекомендовано використовувати технології,
які мають багато ресурсів де можна знайти відповіді на запитання та багато написаних
бібліотек які допоможуть зекономити час і гроші при розробці сайту середнього розміру.

Наступним етапом стала адаптація NextJS За рекомендацію друга який є професіональним розробником в фронтенді.Я почав вивчати його.
Цей фрейморк надає інфраструктуру для написання швидких сайтів включаючи платформу для хостингу, SSG сторінок, SSR, та serverless функції.
Це дозволяє зосередитись на розробці сайту, а не на інфраструктурних питаннях.

Для великих та важливих проектів я не рекомендую використовувати цю технологію бо вона занадто
багато визначає процес розробки і тож не є достатньо гнучкою для постійно змінюваних умов.

Більшість провідних компаній які розробляють топ1 фронтенд у світі використовують React.
Це пов'язано з тим що бібліотека є де-факто стандартом розробки швидких сайтів має багато
бібліотек наприклад отримання швидкості з'єднання, об'єму пам'яті, швидкості процесора,
з'єднання з інтернетом та інших параметрів у простий спосіб не дивлячись на деталі специфікації,
які описують деталі отримання цих параметрів з пристроїв.
\section{Опис основних метрик}
\subsection{FCP}
FCP(First contentful paint) швидкість загрузки, ця метрика вимірює час який потрібен браузеру для того щоб загрузити перший DOM
елемент, після того як користувач перейшов на сторінку.
Картинки, SVG та непусті canvas елементи вважаються DOM контентом, будь-що усередині iframe не включається.
Для оптимізації цієї метрики треба у першу чергу загружати тільки необхідні дані. Для цього можна використати LazyLoad.
Компоненти, тобто Javascript код, картинки та інші частини тієї частки сайту яка не потрібна буд відкладено на потім.
Зазвичай у першу чергу має бути загружений скелет сайту, він є легкою частиною швидко загружається та надає користувачам
необхідний зворотній зв'язок.
Не впевнений, що загружати найбільший елемент сторінки першим є вірним рішенням,
бо при низькій швидкості з'єднання з інтернетом це може зайняти доволі багато часу.
\subsection{Time to interactive}
Time to interactive(TTI)
Ця метрика є важливою, тому що деякі сайти оптимізують видимий контент ціною відкладання інших задач на потім.
Через це користувач може мати поганий досвід користування веб-сайтом, бо сторінка буде заблокована
і користувач не зможе нічого робити.
Метрика вимірює час який потрібен сторінці до того, як вона стане повністю інтерактивною.
Сторінка вважається повністю інтерактивною коли:
\begin{enumerate}
    \item Сторінка показала увесь корисний контент, що вимірюється FCP.
    \item Усі event-handlers зареєстровані для більшості видимих елементів сторінки.
    \item Сторінка відповідає на інтеракції користувача в рамках 50 мілісекунд.
\end{enumerate}

Ця метрика вимірюється за допомогою порівняння даних з іншими сайтами.
Наприклад якщо 99 відсотків сайтів мають значення х і ваш сайт має значення >= x, то значення цієї метрики буде становити 99.

Ця метрика може бути покращена за допомогою відкладання виконання непотрібного одразу коду на потім.

\subsection{Speed Index}
Індекс швидкості вимірює те, як швидко контент візуально з'являється на протязі загрузки сторінки.
Вимірювальних у 1-у чергу знімає відео, як загружається сторінка в браузері і вираховує візуальну прогресію між кадрами.
Для оптимізації індексу швидкості можна робити все що пришвидшує роботу сайту.
Наприклад мінімізація нагрузки на головному потоці, зменшення виконання скриптів, а також перевірка того,
що текст залишається видимим упродовж загрузки веб-шрифтів.

\subsection{Total Blocking Time}
Це метрика вимірюється у мілісекундах. Час до першого байта вимірює загальний час на протязі якого сторінка заблокована
і не відповідає користувачу, наприклад, на кліки мишкою, натиски на екран або на клавіатуру.

Сума вираховується таким чином: це сума усіх блокуючих частин усіх довгих задач.
Усі задачі, які виконуються більше п'ятидесяти мілісекунд є довгими.
Час після 50 мілісекунд є блокуючєю частиною.
Наприклад, якщо задачі займають 70 мілісекунд блокуюча порція буде дорівнювати 20 секунд мілісекунд.
Найчастіше частини поганого значення цієї метрики пов'язані з виконанням загрузкою, парсингом загрузкою паркінгу та виконання непотрібного коду.
За допомогою Performance панелі ви можете віднайти основні задачі які лягають на основний потік.
Також допомогає покращення власного коду з точки зору алгоритмічної складності.

\subsection{LCP}
Найбільша видима картинка, ця мерика вимірює час, який потрібно найбільшому елементу сторінки для появи у видимій частині сторінки і рендер.
Це є апроксимацію часу загрузки основного контенту. Мінусом цієї метрики за моїм досвідом є те що вона може неправильно визначати основний контент сторінки.
Наприклад коли на мобільному пристрої загружається дві картинки одна з яких основна і займає весь екран, а інша займає наприклад 10 відсотків екрану і при цьому вони мають однаковий розмір, Lighthouse report може вважати основною картинкою не ту яка дійсно основна, а іншу.
Це потребує змін коду тільки раді швидкості на бенчмарку, що не є бажаним, але саме за цими даними вираховується рейтинг сторінки.
В загальному випадку оптимізація цього значення складається з відкладання непотрібної роботи, адаптивної загрузки картинок та інші.

\subsection{CLS}
Ця метрика вимірює наскільки як сильно елементи дергаються на сторінці.
Наприклад читаючи текст на сторінці без попередження текст переміщується і ви втрачаєте місце де читали,
іноді це навіть може призвести до серйозних проблем.
Загалом сервіси, що дергаються є неприємними для користувачів. https://web.dev/cls/
\section{Опис деяких підходів}
\subsection{Client side rendering}
Він полягає в тому що клієнт отримує Javascript код який будучи скаче ним починає наповнювати сторінку змістом, робити запити.
Мінусом цього підходу є те що об'єм цього Javascript коду може бути доволі великим і треба дочекатись його загрузки перед тим як хоч щось з'явиться на экрані.
Це погіршує метрики.
Також виконання коду на слабких пристроях є повільним і не є бажаним.

\subsection{Server side rendering}
Server side rendering(SSR) полягає в тому що генерація HTML сторінки лежить на сервері.
В порівнянні з іншим методом(Client site rendering), коли браузер спочатку отримує код Javascript і потім робить запити на сервер,
ця техніка дозволяє покращити у деяких випадках майже усі метрики бо не витрачає час на загрузку бібліотек клієнтом,
Дані з бази швидше беруться на сервері ніж якщо робити запит клієнту через фізично близькість та гарне обладнання на хостинг.
Основною перевагою цього підходу є зменшення навантаження на процесор клієнтського пристрою.
Робота по рендерингу лежить на сервері, це критично для мобільних пристроїв.
Мобільні пристрої є головним сегментом вебпростору.
Також плюсом цього підходу є орієнтація на пошукові двигуни.
Їм простіше зчитувати звичайні сторінки і не виконувати Javascript код.

\subsection{Static site generation}
Ця техніка полягає у тому що сторінки генерується під час збірки проекту. Цей спосіб є найбільш ефективним у випадку коли може бути застосований.
Через те що наповнення сторінок вже згенеровано то під час клієнтського запиту клієнт одразу побачить контент на своїй сторінці.

\subsection{Isomorfic apps}
Цей підхід є поєднанням першого та другого.
Він полягає в тому що основна робота по рендерингу зображення лежить на сервері,
проте після першої загрузки починається робота на клієнті.

Цей підхід поєднує гарні сторони обох інших підходів. Проте ніякий підхід не є універсальним.

На моєму сайті був застосований цей спосіб.
