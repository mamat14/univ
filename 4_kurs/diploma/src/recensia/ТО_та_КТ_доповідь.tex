\documentclass[a4paper,14pt, titlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}

\usepackage[english, ukrainian]{babel}

\usepackage{amsmath,amssymb,mathrsfs}

\usepackage{amsthm}
\usepackage[mathscr]{eucal}
%\usepackage[dvips]{graphicx}
\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}


%\usepackage[centerlast,small]{caption2}
\usepackage{enumerate}
\usepackage{verbatim}
\usepackage{layout}
\usepackage{cite}
%%% remove comment delimiter ('%') and specify parameters if required
%\usepackage[dvips]{graphics}

\usepackage{hyperref}
\tolerance=1000
\hypersetup{colorlinks=true}

\pagestyle{empty}

\usepackage{geometry} % Можливість задавати поля
\geometry{top=15mm}
\geometry{bottom=15mm}
\geometry{left=15mm}
\geometry{right=10mm}

\usepackage{extsizes} % Можливість зробити 14-й шрифт(8pt, 9pt, 10pt, 11pt, 12pt, 14pt, 17pt, 20pt.)

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
    keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={class, export, boolean, throw, implements, import, this},
    ndkeywordstyle=\color{darkgray}\bfseries,
    identifierstyle=\color{black},
    sensitive=false,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{purple}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    morestring=[b]',
    morestring=[b]"
}

\lstset{
    language=JavaScript,
    extendedchars=true,
    basicstyle=\footnotesize\ttfamily,
    showstringspaces=false,
    showspaces=false,
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=9pt,
    tabsize=2,
    breaklines=true,
    showtabs=false,
    captionpos=b
}



\title{Модульність. Специфікація інтерфейсу компоненту.}
\author{Маматюсупов Дмитрій}
\date{Листопад 2020}

\begin{document}

\maketitle

\tableofcontents


\section{Вступ}
В основі тієї чи іншої мови програмування лежить якась керівна ідея,
викликана потребами або, найчастіше, кризою в області програмування і
створення програмного забезпечення, яка має суттєвий вплив на стиль
програмування і допомагає подолати зазначений криза [9]. Розглянемо
коротко історію появи і розвитку основних стилів програмування і
процедурних алгоритмічних мов.


\paragraph{Машинно-орієнтоване програмування}
з'явилося одночасно зі створенням електронних обчислювальних машин.
Спочатку це були програми на машинному коді, потім з'явилася мова
програмування Assembler (Автокод), який трохи «олюдинив» написання
програми в машинному коді. Ц й стиль програмування передбачає
досконале знання можливостей конкретної архітектури ЕОМ і операційної
системи і використовується до цих пір тоді, коли інші стилі безсилі, або
потрібно отримати максимальну швидкодію в рамках тієї чи іншої
операційної системи з використанням архітектури даної ЕОМ.

\paragraph{Процедурне програмування}
Основна ідея цього стилю - алгоритмізація процесу рішення задачі і вибір
найкращого алгоритму (по витраті пам'яті або за швидкодією). Реалізація
цієї ідеї почалася з 1957 року з появою алгоритмічних мов Fortran і
потім Algol-60, коли все більше і великі число фахівців зайнялося
рішенням досить складних інженерних і наукових завдань. І потрібен був
стиль програмування максимально близький до людського (математичного)
стилю. При цьому знання тонкощів архітектури ЕОМ не було потрібнім.
Програма на алгоритмічній мові (при наявності відповідних трансляторів)
повинна була в ідеалі працювати на ЕОМ будь-якої архітектури. Але це
були програми прикладні. Розробку ж системних програм (самих
трансляторів, систем введення-виведення) як і раніше треба було робити
на Асемблері.

\paragraph{Структурне програмування.}
Тут основна ідея прекрасно виражена Н. Віртом в його книзі ``Алгоритми +
структури даних = програми''. Це була відповідь на кризу в області
програмування, що почався в середині 60-х годів, коли обсяг вихідного
програмного коду перейшов рубіж в 1000 рядків. У 1971 році з'явився
алгоритмічна мова Pascal і трохи пізніше, в 1972 році, мова С.
Алгоритмічні мови стали більш потужними, більш ``інтелектуальними'', на
них вже можна було писати елементи трансляторів (компіляторів) і
драйверів (підпрограм обробки вводу-виводу). Компілятори з мов С і
Fortran видають, наприклад, на вимогу програміста і лістинг програми на
Асемблері. Знаючий Асемблер програміст може його проаналізувати, щось
підправити і перекомпіліровать, але вже на Асемблері. В цьому випадку
можна досить швидко і ефективно отримувати системні програми.

\paragraph{Модульне програмування.}

Тут основна ідея полягала в тому, щоб ``сховати'' дані і процедури
всередині незалежних програмних одиниць - модулів . Цю ідею вперше
реалізував Н. Вірт в алгоритмічній мові Modula (1975-1979 роки), а потім
``підхопили'' і інші, поширені в той час мови програмування. Наприклад,
відомі системи програмування Turbo Pascal і Turbo С.

\paragraph{Об'єктно-орієнтоване програмування.}

З середини 80-х років обсяг вихідного програмного коду перейшов рубіж в
100 000 рядків. Потрібно було зробити не випадковий об'єднання даних і
алгоритмів їх обробки в єдине ціле, а - смислове. Тобто необхідно було
створити модульне програмування нового рівня, коли основний акцент
робиться на смисловий зв'язок структур даних і алгоритмів їх обробки.
Зараз практично всі основні мови програмування (їх понад 100, в тому
числі такі поширені, як Object Pascal, C ++, Smalltalk) базуються на цій
ідеї, а предком їх є мова Simula, створена ще в 1960 році.

\paragraph{Узагальнені технології розробки додатків.}

Ідеологія об'єктно-орієнтованого програмування породила CASE-технології
розробки і збірки програм на основі вже відомих програмних моделей, що
містять інтерфейси і прототипи (шаблони - template) даних: COM
(Component Object Model), STL (Standard Template Library), ATL (Active
Template Library ). Всі ці нововведення підтримують візуальні середовища
розробки, наприклад, такі відомі, як Visual C++, Borland C++ Builder,
Borland Delphi. Тепер детально розглянемо технологію модульного
програмування.


\section{Мета модульного програмування}
Приступаючи до розробки кожної програми, слід мати на увазі, що вона, як
правило, є великою системою, тому треба вжити заходів для її спрощення.
Для цього таку програму розробляють окремими частнинами, які називаються
програмними модулями [1, 2]. А сам такий метод розробки програм
називають модульним програмуванням [3]. Програмний модуль - це
будь-який фрагмент опису процесу, що оформляється як самостійний
програмний продукт, придатний для використання в описах процесу. Це
означає, що кожен програмний модуль програмується, компілюється та
налагоджували окремо від інших модулів програми, і тим самим, фізично
розділений з іншими модулями програми. Більш того, кожен розроблений
програмний модуль може включатися до складу різних програм, якщо
виконані умови його використання, декларовані в документації з цього
модулю. Таким чином, програмний модуль може розглядатися і як засіб
боротьби зі складністю програм, і як засіб боротьби з дублюванням в
програмуванні (тобто як засіб накопичення та багаторазового використання
програмістських знань).

Модульне програмування є втіленням в процесі розробки програм обох
загальних методів боротьби зі складністю: і забезпечення незалежності
компонент системи і використання ієрархічних структур. Для втілення
першого методу формулюються певні вимоги, яким повинен задовольняти
програмний модуль, тобто виявляються основні характеристики «хорошого»
програмного модуля. Для втілення другого методу використовують
деревоподібні модульні структури програм (включаючи дерева зі зрослими
гілками).

\subsection{Основні характеристики програмного модуля}

Не всякий програмний модуль сприяє спрощенню програми [2]. Виділити
хороший з цієї точки зору модуль є серйозним творчим завданням. Для
оцінки прийнятності виділеного модуля використовуються деякі критерії.
Так, Хольт [4] запропонував наступні два загальних таких критерії:
\begin{enumerate}
    \item хороший модуль зовні простіше, ніж усередині
    \item хороший модуль простіше використовувати, ніж побудувати.
\end{enumerate}

Майерс [5] пропонує для оцінки прийнятності програмного модуля
використовувати більш конструктивні його характеристики:
    \item розмір модуля;
    \item міцність модуля;
    \item зчеплення з іншими модулями;
    \item рутинність модуля (незалежність від передісторії звертань до нього).

\emph{Розмір модуля} вимірюється числом містяться в ньому операторів або
рядків. Модуль не повинен бути занадто маленьким або занадто великим.
Маленькі модулі призводять до громіздкої модульної структурі програми і
можуть не окупати накладних витрат, пов'язаних з їх оформленням. Великі
модулі незручні для вивчення і змін, вони можуть істотно збільшити
сумарний час повторних трансляцій програми при налагодженні програми.
Зазвичай рекомендуються програмні модулі розміром від кількох десятків
до кількох сотень операторів.

\emph{Міцність модуля} - це міра його внутрішніх зв'язків. Чим вище міцність
модуля, тим більше зв'язків він може сховати від зовнішньої по
відношенню до нього частини програми і, отже, тим більший внесок в
спрощення програми він може внести. Для оцінки ступеня міцності модуля
Майерс [5] пропонує упорядкований за ступенем міцності набір із семи
класів модулів. Найслабшою ступенем міцності володіє модуль, міцний по
збігу . Це такий модуль, між елементами якого немає осмислених зв'язків.
Такий модуль може бути виділений, наприклад, при виявленні в різних
місцях програми повторення однієї і тієї ж послідовності операторів, яка
і оформляється в окремий модуль. Необхідність зміни цієї послідовності в
одному з контекстів може привести до зміни цього модуля, що може зробити
його використання в інших контекстах помилковим. Такий клас програмних
модулів не рекомендується для використання. Взагалі кажучи,
запропонована Майерсом впорядкованість за ступенем міцності класів
модулів не безперечна. Однак, це не дуже суттєво, так як тільки дві вищі
за міцністю класу модулів рекомендуються для використання. Ці класи я
розгляну докладніше.

Функціонально міцний модуль - це модуль, що виконує (реалізує) одну
яку-небудь певну функцію. При реалізації цієї функції такий модуль може
використовувати і інші модулі. Такий клас програмних модулів
рекомендується для використання.

Інформаційно міцний модуль - це модуль,
що виконує (реалізує) кілька операцій (функцій) над однією і тією ж
структурою даних (інформаційним об'єктом), яка вважається невідомою поза
цим модуля. Для кожної з цих операцій в такому модулі є свій вхід зі
своєю формою звернення до нього. Такий клас слід розглядати як клас
програмних модулів з вищим ступенем міцності. Інформаційно міцний модуль
може реалізовувати, наприклад, абстрактний тип даних. У модульних мовах
програмування як мінімум є засоби для завдання функціонально міцних
модулів (наприклад, модуль типу FUNCTION в мові ФОРТРАН). А кошти для
завдання інформаційно міцних модулів в ранніх мовах програмування були
відсутні. Ці кошти з'явилися тільки в більш пізніх мовами. Так в мові
програмування Ада засобом завдання інформаційно міцного модуля є пакет
[6].

\emph{Зчеплення модуля} - це міра його залежності за даними від інших модулів.
Характеризується способом передачі даних. Чим слабкіше зчеплення модуля
з іншими модулями, тим сильніше його незалежність від інших модулів. Для
оцінки ступеня зчеплення Майерс пропонує [5] упорядкований набір з
шести видів зчеплення модулів. Найгіршим видом зчеплення модулів є
зчеплення по вмісту . Таким є зчеплення двох модулів, коли один з них
має прямі посилання на вміст іншого модуля (наприклад, на константу, що
міститься в іншому модулі). Таке зчеплення модулів неприпустимо. Не
рекомендується використовувати також зчеплення із загальної області - це
таке зчеплення модулів, коли кілька модулів використовують одну і ту ж
область пам'яті. Такий вид зчеплення модулів реалізується, наприклад,
при програмуванні на мові ФОРТРАН з використанням блоків COMMON. Єдиним
видом зчеплення модулів, який рекомендується для використання сучасною
технологією програмування, є параметричне зчеплення ( зчеплення за
даними по Майерсу [5]) - це випадок, коли дані передаються модулю
або при звертанні до нього як значення його параметрів, або як результат
його звернення до іншого модулю для обчислення деякої функції. Такий вид
зчеплення модулів реалізується на мовах програмування при використанні
звертань до процедур (функції).

\emph{Рутинність модуля} - це його незалежність від передісторії звертань до
нього. Модуль називається рутинним , якщо результат (ефект) звертання до
нього залежить тільки від значень його параметрів (і не залежить від
передісторії звертань до нього). Модуль називається залежним від
передісторії , якщо результат (ефект) звертання до нього залежить від
внутрішнього стану цього модуля, змінюваного в результаті попередніх
звернень до нього. Майерс [5] не рекомендує використовувати залежні
від передісторії (непередбачені) модулі, так як вони провокують появу в
програмах хитрих (невловимих) помилок. Однак така рекомендація є
неконструктивною, тому що в багатьох випадках саме залежний від
передісторії модуль є кращою реалізацій інформаційно міцного модуля.
Тому більш прийнятна наступна (більш обережна) рекомендація:

\begin{enumerate}
    \item завжди
    слід використовувати рутинний модуль, якщо це не призводить до поганих
    (не рекомендованих) зчепленнь модулів;
    \item залежні від передісторії модулі
    варто використовувати тільки в разі, коли це необхідно для забезпечення
    параметричного зчеплення;
    \item в специфікації залежного від передісторії
    модуля повинна бути чітко сформульована ця залежність таким чином, щоб
    було можливо прогнозувати поведінку (ефект виконання) даного модуля при
    різних наступних звертаннях до нього.
\end{enumerate}

У зв'язку з останньою рекомендацією може бути корисним визначення
зовнішнього подання (орієнтованого на інформування людини) станів
залежитей від передісторії модуля. В цьому випадку ефект виконання кожної
функції (операції), що реалізується цим модулем, слід описувати в
термінах цього зовнішнього представлення, що істотно спростить
прогнозування поведінки даного модуля.

\section{Проектування модуля}

Модульне проектування відноситься до процесу розділення великих
проблем на більш вузькі, більш керовані підпроблеми. Першим кроком
проектування є рішення, в якому місці має бути межа між цими
підзадачами. Для отримання максимальних переваг від використання
модульного програмування кожна підзадача або модуль повинні мати один
вхід і один вихід. В цьому випадку можна легко відстежувати потік
управління в програмі. У будь-якому місці модуля повинна бути можливість
побачити точку входу в модуль і визначити точне значення змінних і
регістрів в цій точці, а потім простежити функціонування модуля без
помилок у програмі. Один вхід забезпечує повернення потоку
управління в точку виклику. З цієї причини, модульні програми майже
завжди виконуються як структури «CALL - RET». Використання декількох
пропозицій RET в модулі не повинно порушувати правило одного входу,
оскільки всі інструкції RET повертають управління в одну й ту ж саму
точку. Точно також, перехід до загального RET в кінці модуля, не змінює
його структуру, а додає лише коди та збільшує його складність. З іншого
боку, вхід або вихід з модуля не за цим правилом перекреслює найбільші
переваги модульного програмування: ясність і зручність супроводу. Є
виключення з правила входу в модуль. Це відбувається при використанні
таблиці переходів для реалізації потоку управління всередині програми.
Таблиця переходу використовується шляхом «проштовхування» адреси
повернення в стек, обчислення індексу необхідної адреси переходу в
таблиці і виконання переходу в пам'яті. При практичному виконанні
декомпозиції модулів можна самим знайти кілька альтернативних рішень.
Перш ніж здійснити правильний вибір, необхідно знати альтернативи. Мета
полягає у виборі таких варіантів, які створять найкращі умови
проектування.

\subsection{Функціональна декомпозиція}

При зверненні до проблеми на стадії проектування першим альтернативним
вибором повинна бути функціональна декомпозиція, тобто розбиття проблеми
на більш вузькі, цілком піддаються управлінню функціональні одиниці, де
кожна одиниця виконує завершену, легко ідентифікується завдання. Є
безліч шляхів визначення змісту завдання. Ось лише деякі приклади
подібних одиниць, які виконують певні функції: отримання квадратного
кореня деякого числа; виконання всіх операцій щодо зазначеного пристрою
таких, як операції в/в диска, операції в/в клавіатури; виконують
загальну групу дій в зазначений час такі, як ініціалізація областей
даних; і одиниці, які взаємодіють послідовно або використовують загальні
елементи даних такі, як зчитування даних з клавіатури і перетворення їх
в цілі значення. В даний час в області програмування на мовах високого
рівня найчастіше приймаються такі рішення, які являють собою найкращий
спосіб по використанню сегментації програм. Часто виявляється, що деякі
модулі зв'язуються за допомогою одного набору критеріїв, а інші модулі -
за допомогою іншого. Кожен модуль повинен включати легкі для розуміння
програмні секції.


\subsection{Мінімізації кількості переданих параметрів}

Іноді виявляється, що після визначення модулів програми створено щось
громіздке і незграбне. Це часто трапляється тоді, коли модулі при
виконанні покладених на них завдань вимагають доступу до великого
кількості даних. Найчастіше це легко може статися, якщо на модуль
покладено виконання кількох опцій. Щоб знати стан програми в даний час,
модуль повинен приймати дуже багато різних змінних. Якщо це так, і
виявлено, що модуль приймає велику кількість параметрів, необхідно
відповісти на наступні дві групи питань:
\begin{enumerate}
    \item Чи у цьому модулі зроблена
    спроба виконання декількох функцій? Чи потребує модуль параметри, які
    використовуються в ньому що не відносяться до даногих в модулю секціях? Якщо
    відповіді на ці питання позитивні, то необхідно знову звернутися до
    подальшої сегментації цього модуля.
    \item Чи модуль представляє собою
    функціональний розріз? Чи є насправді викликаючий та модуль частиною
    однієї і тієї ж функції? Якщо це так, то помістіть їх разом в один
    модуль, навіть якщо результуючий модуль виявиться занадто великим. Потім
    спробуйте виконати сегментацію модуля знову різними способами.
\end{enumerate}

Сегментація модулів через функціональний розріз часто відбувається тоді,
коли програміст виявляє, що дві програмні секції ідентичні або сильно
схожі один на одного. Програміст потім намагається створити з них один
модуль. Це не модульне програмування, оскільки результуючий модуль має
не функціональне з'єднання. Якщо в процесі проектування буде виявлено,
що нічого зробити не можна, щоб уникнути використання великої кількості
посилань на дані або передачі міток параметрів, треба повернутися назад
в початок проектування і перевірити коректність поставленої проблеми.

\subsection{Мінімізації кількості необхідних викликів}

Одним з істотних переваг модульного програмування є те, що програма
основного рівня дуже часто може бути сконструйована для читання як
послідовність викликаються процедур. Цей факт істотно підвищує
«зрозумілість» програми, оскільки читач може познайомитися з її основним
потоком і функціонуванням після прочитання тільки однієї - двох сторінок
програмного коду. Однак ця особливість може також мати і недоліки. Одна
з багатьох верхніх статистичних оцінок програмування говорить про те, що
90\% часу виконання типових програм витрачається в 10\% коду програми.
При цьому мається на увазі, що якщо ці 10\% містять велику кількість
ланцюгових викликів процедур, то сумарний час, що витрачається на
управління виконанням програми, може стати непереборною перешкодою на
шляху використання цього підходу.

Перш ніж відмовитися від модульности проектованої програми, треба
перевірити, що ховається під залежністю програми від часу. По-перше,
багато програм витрачають велику частину часу виконання на очікування
введення інформації з клавіатури. Після натискання клавіші необхідні
функції, з точки зору виконання тривалого процесу, зазвичай не
витрачають час. Різниця між 100 мікросекунд і 100 мілісекунд для
середнього користувача є непомітною.

Протилежним для деяких думкою є те, що діючий механізм пари CALL - RET
не перекриває спожите час. У порівнянні з інструкціями переходу
інструкція CALL виконується на 30-50\% довше, а RET в середньому довші
на 1 цикл. Тільки коли до уваги беруться накладні витрати передачі
параметрів, збереження регістрів і т.д., звані службовими витратами,
модульні програми починають виглядати повільніше в порівнянні з
немодульность програмами. На додаток до того, що модулі модульних
програм зазвичай є більш загальними, ніж їх неструктуровані дублікати,
модулі модульних програм можуть використовувати посилання на пам'ять або
стек з більшою частотою. Додатковий час, що витрачається на обчислення
дійсної адреси в тілі модуля, може привести до уповільнення виконання
конкретного модуля, ніж вузько закодована конкретна програма.

Переваги службових програм і програм загального призначення полягають в
тому, що модуль може бути використаний віртуально в деякому місці
програми. При написанні немодульної програми програміст може витратити
кілька годин, намагаючись відкрити: чи використовується регістр
(змінна), або гірше того, чи правильно те, що він повинен
використовуватися. При модульному програмуванні програміст не цікавиться
тим, які регістри (змінні) він використовує в даний момент, поки що
викликається модуль копіює його параметри в стек і зберігає весь набір
регістрів на вході. Ці особливості створюють можливість спочатку
використовувати прийоми модульного програмування для підвищення
швидкості кодування і потім переробки програми для видалення ``вузьких''
місць.

Для областей, чутливих до швидкості роботи, кращою рекомендацією є вибір
основної гілки програми. Якщо модуль згадується тільки в чутливій до
швидкості роботи програмній секції, то він може бути включений в
``гілку'' всередині виклику модуля. Якщо інші секції використовують
модуль, то вони можуть бути скопійовані в модулі, що викликається в потрібне
місце. У зв'язку з тим, що основний код, що викликає модуль, стане великим,
необхідно вставити коментарі в його тіло, позначати де включається модуль
як блок його власника. Майбутні читачі зможуть потім прочитати коментарі
для визначення функцій модуля і пропустити його повз для відновлення
читання основного коду.

\section{Методи розробки структури модульної програми}

Як вже зазначалося вище, в якості модульної структури програми прийнято
використовувати деревоподібну структуру, включаючи дерева зі зрослими
гілками. У вузлах такого дерева розміщуються програмні модулі, а
спрямовані дуги (стрілки) показують статичну підпорядкованість модулів,
тобто кожна дуга показує, що в тексті модуля, з якого вона виходить, є
посилання на модуль, до якого вона входить. Іншими словами, кожен модуль
може звертатися до підлеглих йому модулів, тобто виражається через ці
модулі. При цьому модульна структура програми, в кінцевому рахунку,
повинна включати і сукупність специфікацій модулів, що утворюють цю
програму. Специфікація програмного модуля містить:
\begin{enumerate}
    \item синтаксичну
    специфікацію його входів, що дозволяє побудувати на використовувану мову
    програмування синтаксично правильне звертання до нього (до будь-якого
    його входу);
    \item функціональну специфікацію модуля (опис семантики
    функцій, які виконуються цим модулем по кожному з його входів).
\end{enumerate}

У процесі розробки програми її модульна структура може по-різному
формуватися і використовуватися для визначення порядку програмування і
налагодження модулів, зазначених у цій структурі. Тому можна говорити
про різні методи розробки структури програми. Зазвичай в літературі
обговорюються два методи [1, 7]: метод висхідної розробки і метод
низхідної розробки.

\subsection{Метод висхідної розробки}

Даний метод полягає в наступному. Спочатку будується модульна структура
програми у вигляді дерева. Потім по черзі програмуються модулі програми,
починаючи з модулів найнижчього рівня (листя дерева модульної
структури програми), в такому порядку, щоб для кожного програмованого
модуля були вже запрограмовані всі модулі, до яких він може звертатися.
Після того, як всі модулі програми запрограмовані, проводиться їх
почергове тестування і налагодження в принципі в такому ж (висхідному)
порядку, в якому велося їх програмування. Такий порядок розробки
програми на перший погляд здається цілком природним: кожен модуль при
програмуванні виражається через уже запрограмовані безпосередньо
підлеглі модулі, а при тестуванні використовує вже налагоджені модулі.
Однак, сучасна технологія не рекомендує такий порядок розробки програми.
По-перше, для програмування якого-небудь модуля зовсім не потрібно
наявності текстів використовуваних їм модулів - для цього досить, щоб
кожен використовуваний модуль був лише специфікований (в обсязі, що
дозволяє побудувати правильне звертання до нього), а для тестування його
можливо (і навіть , як ми покажемо нижче, корисно) використовувані
модулі заміняти їх імітаторами (заглушками). По-друге, кожна програма в
якійсь мірі підпорядковується деяким внутрішнім для неї, але глобальним
для її модулів міркувань (принципам реалізації, припущенням, структурам
даних і т.п.), що визначає її концептуальну цілісність і формується в
процесі її розробки. При висхідній розробці ця глобальна інформація для
модулів нижніх рівнів ще не ясна в повному обсязі, тому дуже часто
доводиться їх перепрограмувати, коли при програмуванні інших модулів
виробляється істотне уточнення цієї глобальної інформації (наприклад,
змінюється глобальна структура даних). По-третє, при висхідному
тестуванні для кожного модуля (крім головного) доводиться створювати
провідну програму (модуль), яка повинна підготувати для модуля, що
тестується необхідний стан інформаційного середовища і зробити необхідне
звернення до нього. Це призводить до великого обсягу «отладочного»
програмування і в той же час не дає ніякої гарантії, що тестування
модулів вироблялося саме в тих умовах, в яких вони будуть виконуватися в
робочій програмі.

\subsection{Метод низхідної розробки}

Метод низхідної розробки полягає в наступному. Як і в попередньому
методі спочатку будується модульна структура програми у вигляді дерева.
Потім по черзі програмуються модулі програми, починаючи з модуля самого
верхнього рівня (головного), переходячи до програмування якого-небудь
іншого модуля тільки в тому випадку, якщо вже запрограмований модуль,
який до нього звертається. Після того, як всі модулі програми
запрограмовані, проводиться їх почергове тестування і налагодження в
такому ж (низхідному) порядку. При цьому першим тестується головний
модуль програми, який представляє всю програму, що тестується, і тому
тестується при «природному» стані інформаційного середовища, при якому
починає виконуватися ця програма. При цьому ті модулі, до яких може
звертатися головний, заміняються їх імітаторами (так званими заглушками
[5]). Кожен імітатор модуля представляється вельми простим
програмним фрагментом, який, в основному, сигналізує про сам факт
звернення до імітованого модулю, виробляє необхідну для правильної
роботи програми обробку значень його вхідних параметрів (іноді з їх
роздруківкою) і видає, якщо це необхідно, заздалегідь запасені
відповідний результат. Після завершення тестування і налагодження
головного і будь-якого подальшого модуля проводиться перехід до
тестування одного з модулів, які в даний момент представлені
імітаторами, якщо такі є. Для цього імітатор обраного для тестування
модуля заміняється самим цим модулем і, крім того, додаються імітатори
тих модулів, до яких може звертатися обраний для тестування модуль. При
цьому кожен такий модуль буде тестуватися при «природних» станах
інформаційного середовища, що виникають до моменту звернення до цього
модулю при виконанні програми, що тестується. Таким чином, великий обсяг
«отладочного» програмування при висхідному тестуванні замінюється
програмуванням досить простих імітаторів використовуваних в програмі
модулів. Крім того, імітатори зручно використовувати для того, щоб
підігравати процесу підбору тестів шляхом завдання потрібних
результатів, видаваних імітаторами. При такому порядку розробки програми
вся необхідна глобальна інформація формується вчасно, тобто ліквідується
вельми неприємне джерело прорахунків при програмуванні модулів. Деяким
недоліком низхідної розробки, що призводить до певних ускладнень при її
застосуванні, є необхідність абстрагуватися від базових можливостей
використовуваної мови програмування, вигадуючи абстрактні операції, які
пізніше потрібно буде реалізувати за допомогою виділених у програмі
модулів. Однак здатність до таких абстракцій представляється необхідною
умовою розробки великих програмних засобів, тому її потрібно розвивати.

\subsection{Конструктивний і архітектурний підходи}

Особливістю розглянутих методів висхідної і низхідної розробоки є вимога,
щоб модульна структура програми була розроблена до початку програмування
(кодування) модулів. Розробка модульної структури програми і її
кодування виробляються на різних етапах розробки програмного засобу
(ПС): перша завершує етап конструювання ПС, а друге - відкриває етап
кодування. Однак ці методи викликають ряд заперечень: видається
сумнівним, щоб до програмування модулів можна було розробити структуру
програми досить точно і змістовно. Насправді це робити не обов'язково.
Нижче описуються конструктивний і архітектурний підходи до розробки
програм [3], в яких модульна структура формується в процесі
програмування (кодування) модулів.

\textbf{Конструктивний підхід} до розробки програми є модифікацією
низхідної розробки, при якій модульна деревоподібна структура програми
формується в процесі програмування модулів. Розробка програми при
конструктивному підході починається з програмування головного модуля,
виходячи з специфікації програми в цілому. При цьому специфікація
програми приймається в якості специфікації її головного модуля, який
повністю бере на себе відповідальність за виконання функцій програми. У
процесі програмування головного модуля, в разі, якщо ця програма досить
велика, виділяються підзадачі (внутрішні функції), в термінах яких
програмується головний модуль. Це означає, що для кожної виділеної
підзадачі (функції) створюється специфікація, що реалізує фрагмент її
програми, який в подальшому може бути представлений деяким піддеревом
модулів. Важливо зауважити, що тут також відповідальність за виконання
виділеної функції несе головний (можливо, і єдиний) модуль цього
піддерева, так що специфікація виділеної функції є одночасно і
специфікацією головного модуля цього піддерева. У головному модулі
програми для звернення до виділеної функції будується звернення до
головного модулю зазначеного піддерева відповідно до створеної його
специфікацією. Таким чином, на першому етапі розробки програми (при
програмуванні її головного модуля) формується наприклад верхня початкова частина
дерева. Аналогічні дії проводяться при програмуванні
будь-якого іншого модуля, який вибирається з поточного стану дерева
програми з числа специфікованих, але поки ще не запрограмованих модулів.
В результаті цього проводиться чергове деформування дерева програми.

\textbf{Архітектурний підхід} до розробки програми є модифікацією
висхідної розробки, при якій модульна структура програми формується в
процесі програмування модуля. Але при цьому ставиться істотно інша мета
розробки: підвищення рівня використовуваної мови програмування, а не
розробка конкретної програми. Це означає, що для заданої предметної
області виділяються типові функції, кожна з яких може використовуватися
при вирішенні різних завдань в цій області, і специфицируются, а потім і
програмуються окремі програмні модулі, які виконують ці функції. Так як
процес виділення таких функцій пов'язаний з накопиченням і узагальненням
досвіду вирішення завдань в заданій предметній області, то зазвичай
спочатку виділяються і реалізуються окремими модулями більш прості
функції, а потім поступово з'являються модулі, що використовують раніше
виділені функції. Такий набір модулів створюється в розрахунку на те, що
при розробці тієї чи іншої програми заданої предметної області в рамках
конструктивного підходу можуть виявитися прийнятними деякі з цих
модулів. Це дозволяє істотно скоротити трудомісткість розробки
конкретної програми шляхом підключення до неї заздалегідь заготовлених і
перевірених на практиці модульних структур нижнього рівня. Так як такі
структури можуть багаторазово використовуватися в різних конкретних
програмах, то архітектурний підхід може розглядатися як шлях боротьби з
дублюванням в програмуванні. У зв'язку з цим програмні модулі, що
створюються в рамках архітектурного підходу, зазвичай параметризуються
для того, щоб посилити застосування таких модулів шляхом настройки їх на
параметри.

\subsection{Інші методи розробки структури модульних програм і їх загальна класифікація}

У класичному методі низхідної розробки рекомендується спочатку  запрограмувати всі
модулі програми, що розробляюсться, а вже потім починати
їх спадне тестування [5]. Однак такий порядок розробки не
представляється досить обгрунтованим: тестування і налагодження модулів
може привести до зміни специфікації підлеглих модулів і навіть до зміни
самої модульної структури програми, так що в цьому випадку програмування
деяких модулів може виявитися марно виконаною роботою. Більш
раціональним є інший порядок розробки програми, відомий в літературі як
метод низхідної реалізації. У цьому методі кожен запрограмований модуль
починають відразу ж тестувати до переходу до програмування іншого
модуля.

Всі ці методи мають ще різні різновиди в залежності від того, в якій
послідовності обходяться вузли (модулі) деревовидної структури програми
в процесі її розробки [1]. Це можна робити, наприклад, по верствам
(розробляючи все модулі одного рівня, перш ніж переходити до наступного
рівня). При низхідної розробці дерево можна обходити також в
лексикографічному порядку (зверху вниз, зліва направо). Можливі й інші
варіанти обходу дерева. Так, при конструктивній реалізації для обходу
дерева програми доцільно слідувати ідеям Фуксмана, які він
використовував у запропонованому ним методі вертикального шарування
[8]. Сутність такого обходу полягає в наступному. В рамках
конструктивного підходу спочатку реалізуються тільки ті модулі, які
необхідні для найпростішого варіанту програми, яка може нормально
виконуватися тільки для дуже обмеженого наборів вхідних даних,
але для таких даних це завдання буде вирішуватися до кінця. Замість
інших модулів, на які в такій програмі є посилання, в цю програму
вставляються лише їх імітатори, що забезпечують, в основному,
сигналізацію про вихід за межі цього окремого випадку. Потім до цієї
програми додаються реалізації деяких інших модулів (зокрема, замість
деяких з наявних імітаторів), що забезпечують нормальне виконання для
деяких інших наборів вхідних даних. І цей процес триває поетапно до
повної реалізації необхідної програми. Таким чином, обхід дерева
програми проводиться з метою найкоротшим шляхом реалізувати той чи інший
варіант (спочатку найпростіший) нормально діючої програми. У зв'язку з
цим такий різновид конструктивної реалізації отримала назву методу
цілеспрямованої конструктивної реалізації. Перевагою цього методу є те,
що вже на досить ранній стадії створюється працюючий варіант програми.
Психологічно це грає роль допінгу, різко підвищує ефективність
розробника. Тому цей метод є досить привабливим.


\section{Контроль структури модульної програми}

На завершення процесу модульного програмування слід етап контролю
структури програми. Для цього можна використовувати три методи:
\begin{enumerate}
    \item статичний контроль
    \item суміжний контроль
    \item наскрізний контроль
\end{enumerate}

\emph{Статичний контроль} полягає в оцінці структури програми, наскільки
добре програма розбита на модулі з урахуванням значень розглянутих вище
основних характеристик модуля.

\emph{Суміжний контроль зверху} - це
контроль з боку розробників архітектури та зовнішнього опису ПС.

\emph{Суміжний контроль знизу} - це контроль специфікації модулів з боку
розробників цих модулів.

\emph{Наскрізний контроль} - це уявне
прокручування (перевірка) структури програми при виконанні заздалегідь
розроблених тестів. Є видом динамічного контролю так само, як і ручна
імітація функціональної специфікації або архітектури ПС. Слід зауважити,
що зазначений контроль структури програми проводиться при класичному
підході. При конструктивному і архітектурному підходах контроль
структури програми здійснюється в процесі програмування (кодування)
модулів в підходящі моменти часу.

\section{Специфікація інтерфейса компонента}
Наведемо приклади специфіцацій на різних мовах програмування та прокоментуємо їх.
Інтерфейси типу функцій розглядати не будемо.
\begin{lstlisting}[style=JavaScript, caption={Компонта на Javascript}]
//definition

/* this function finds a value using id
it throws an error if value isn't found
*/
export const Component = {
  getValue: (id) => { ... }
}

//usage
import {Component} from "./path-to-file"

Component.getValue(id)
\end{lstlisting}
На динамічній мові програмування JavaScript на момент виклику ми знаємо лише кількість параметрів та їх імена та коментар
у випадку якщо такий існує. Навіть якщо коментар існує нема гарантій, що відображає дійсний стан речей.
Для малих програм такий спосіб дає можливість швидкої та комфортної розробки без знань деталей.
В цій програмі інтерфейс присутній у документації, але компілятор не може перевірити правильність викликів.

\begin{lstlisting}[language = Java , firstnumber = last , escapeinside={(*@}{@*)}, caption={інтерфейс на мові Java}]
public interface TreeSet<E extends Comparable<E>> {

    // ...

    /**
    * Test for membership.
    * @param e an element
    * @return true iff this set contains e
    */
    public boolean contains(E e);

    /**
    * Modifies this set by adding e to the set.
    * @param e element to add
    */
    public void add(E e);

    // ...
}
\end{lstlisting}
В мові Java ми маємо інтефейс.
Це дозволяє абстрагуватись від реалізації компоненти у строго типізованій мові.
Також інтерфейс може приймати типи як параметри, як додатковий елемент абстракції.
Цим параметрам можна задавати межі.

\begin{lstlisting}[language = Scala , firstnumber = last, caption={інтерфейси на мові Scala}]
    trait Functor[F[_]] {
        def map[A, B](fa: F[A])(f: A => B): F[B]

        def lift[A, B](f: A => B): F[A] => F[B] = fa => map(fa)(f)
    }

    trait List[T] {
        def cons(t: T, l: List[T]): List[T]
        def head: T
        def tail: List[T]
        def isEmpty
    }

    /* proof (only from type perspective) that list is a Functor lift function is derived automatically */
    val listFunctor = new Functor[List] {
        def map(fa: List[A])(f: A => B): F[B] =
            if(fa.isEmpty) fa
            else cons(f(fa.head), this.map(list.tail)(f))
    }
\end{lstlisting}

В мові Scala ми можемо визначити інтерфейс параметром якого є не тип а конструктор типів.
Це дозволяє визначати властивості більш високого рівня абстракції та уникнути дублювання коду.

\begin{lstlisting}[language = Agda, caption={інтерфейс на мові Agda}]
    data Vec (A : Set) : Nat -> Set where
    []   : Vec A zero
    _::_ : {n : Nat} -> A -> Vec A n -> Vec A (suc n)

    zip : {A B : Set} -> (n : Nat) ->Vec A n -> Vec B n -> Vec (A X B) n
    zip zero v w = <>
    zip (succ n) (a :: v) (b :: w) = <a , b> :: (zip n v w)
\end{lstlisting}
В мові Agda яка є тотальною можливо індексувати тип іншим типом. В цьому
прикладі ми індексували тип Vec типом Nat, а потім індуктивно визначили фукнцію zip
яка має властивість зберігання довжини Vec. В таких мовах тип та інтерфейс є дуже
експресивним.

\section{Висновок}
Підводячи підсумок, хочу сказати, що концепція модульного програмування
повністю задовольняє поставленим цілям. Незважаючи на «еру»
об'єктно-орієнтованого програмування, ця технологія активно
використовується і до цього дня. Засоби створення модулів закладені
практично в усіх мовах високого рівня. Модулі застосовуються також і в
низкорівневому програмуванні, де зрозумілість коду особливо актуальна.

Використання програмних модулів значно спрощує налагодження коду, дає
значні переваги при локалізації помилок, дозволяє швидко і безболісно
внести необхідні зміни в потрібні частини програми. Також, при створенні
великих проектів, дана технологія дозволяє задіяти велику кількість
фахівців, які в свою чергу будуть поламані на більш дрібні групи і
будуть вирішувати конкретну вузько поставлене завдання, доводячи її до
«досконалості». При цьому структурованість і ієрархічність даного
процесу є великим плюсом, тому що швидкість розробки програми
підвищується в кілька разів. Взаємодія між різними групами фахівців
зводитися до мінімуму, тим самим знімаючи можливі непорозуміння.

Ще одною безперечною перевагою є боротьба з дублюванням в програмуванні,
що теж значно підвищує швидкість розробки.

Специфікація інтерфейсу компонети може бути визначена багатьма способами і є важливою її частиною та має відповідати
тим запитам які перед нею поставлені.

\begin{thebibliography}{9}
    \bibitem{a1}
    Дж.Хьюз, Дж.Мічтом.
    \textit{Структурний підхід до програмування.}.
    М .: Світ, 1980. - С. 29-71.

    \bibitem{a2}
    В.Турскій.
    \textit{Методологія програмування.}.
    М .: Світ, 1981. - С. 90-164.

    \bibitem{a3}
    Е.А.Жоголев.
    \textit{Технологічні основи модульного програмування}
    Програмування, 1980, # 2. - С. 44-49.

    \bibitem{a4}
    RCHolt.
    \textit{Structure of Computer Programs: A Survey}
    Proceedings of the IEEE, 1975, 63 (6). - P. 879-893.

    \bibitem{a5}
    Г.Майерс.
    \textit{Надійність програмного забезпечення.}
    М .: Світ, 1980. - С. 92-113.
\end{thebibliography}
\end{document}
